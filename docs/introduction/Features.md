# Features

В основе RAD.js лежит многим знакомый [Backbone.js](http://backbonejs.org/).

Более того если ранее вы писали приложения на Backbone то код написан с использованием RAD.js вам покажется знакомым. Основной целью при разработке была необходимость максимально сохранить существующее Backbone API и при этом не нагромождать его новыми понятиями и методами. Поэтому RAD.js проходит все тесты **Backbone**.

Но тогда возникает вопрос, а чем же RAD.js может мне помочь? Что в нем есть чего нет в самом Backbone или в других фреймворках на его основе.

Мы предлагаем всего две новых фитчи, но они в корне меняют возможности использования **Backbone.js**:

## Работа с DOM   

Если коротко -  RAD.js предлагает иной подход в работе с DOM. Вернее основная идея – это желание избавиться от необходимость работать с DOM и тем самым сконцентрироваться на работе с данными. Для этого мы используем новый [шаблонизатор](https://github.com/Rapid-Application-Development-JS/itemplate) на базе [incremental-dom](https://medium.com/google-developers/introducing-incremental-dom-e98f79ce2c5f#.5mlc5ju6h), который позволяет отрисовывать (render) и обновлять DOM только в местах где изменились данные. А не перерендеривать шаблон заново. Что позволило увеличить быстродействие [на порядок](https://auth0.com/blog/2016/01/11/updated-and-improved-more-benchmarks-virtual-dom-vs-angular-12-vs-mithril-js-vs-the-rest/).   

Это значительно упрощает работу с View. Достаточно описать, как должен выглядеть ваш шаблон в зависимости от в входных данных, а дальше, RAD.js позаботится о том, как нужно обновить DOM.  

Со стороны процесс обновления View становится похожим на обновления компонентов в React.js: меняются данные → вызывается рендер шаблона → обновляется DOM только в тех местах, где данные изменились.   

Но в отличии от React.js или VirtualDOM в RAD.js нет промежуточного виртуального дерева и нет дополнительных затрат на процесс сравнения виртуального и реального DOM.  

При этом вы как и раньше можете использовать существующие инструменты Backbone.js: [Backbone.Model](http://backbonejs.org/#Model), [Backbone.Collection](http://backbonejs.org/#Collection), [Backbone.Router](http://backbonejs.org/#Router).

## Nested View

Говоря честно, нам очень нравиться когда с `view` можно работать как с компонентом, то есть инжектить его в templates, тем самым инкапсулировать функциональность. Работать декларативно. И именно этого функционала очень часто не хватает. Поэтому мы постарались реализовать дополнительные механизмы Dependency Injection для встроенных `view` в нашем фреймверке.

## Заключение  

Как многие смогут заметить, прочитав данную документацию: **RAD.js** очень похож на **Backbone.js** с функциональностью **React.js**.

И хотя нам очень нравится **React.js** своими идеями и мы используем его для написания некоторых из своих приложений, зачем же нужно было изобретать что-то новое?

Существуют как минимум три причины:

* Очень много разработчиков знают **Backbone.js** и иногда именно на основе **Backbone.js** бывает намного проще реализовать необходимую функциональность приложения.
* **RAD.js** как надстройка над **Backbone.js** не вносит каких-либо дополнительных ограничений на структуру и архитектуру вашего приложения. В отличии от того же **React.js**, который тянет за собой новую экоситему, которая совершенствуется каждый день, но которая не может быть идеальна для каждого случая, по простой причине - серебряных пуль просто не существует!
* Разработка любого приложения это использование стороннего кода и сторонних библотек. И именно по этой причине мы использовали **incremental DOM** как наиболее гибкий и производительный движок для Virtual DOM. Который не вносит коллизий при использовании стороннего кода, меняющего структуру DOM.
