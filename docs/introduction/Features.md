# Features

В основе Rad.js лежит многим знакомый [Backbone.js](http://backbonejs.org/).

Более того если ранее вы писали приложения на Backbone то код написан с использованием Rad.js вам покажется знакомым. Основной целью при разработке была необходимость максимально сохранить существующее Backbone API и при этом не нагромождать его новыми понятиями и методами. Поэтому Rad.js проходит все тесты **Backbone**.
  
Но тогда возникает вопрос, а чем же  Rad.js может мне помочь? Что в нем есть чего нет в самом Backbone или в других фреймворках на его основе.

Мы предлагаем всего две новых фитчи, но они в корне меняют возможности использования **Backbone.js**:

## Работа с DOM   

Если коротко -  Rad.js предлагает иной подход в работе с DOM. Вернее основная идея – это желание избавиться от необходимость работать с DOM и тем самым сконцентрироваться на работе с данными. Для этого мы используем новый [шаблонизатор](https://github.com/Rapid-Application-Development-JS/itemplate) на базе [incremental-dom](https://medium.com/google-developers/introducing-incremental-dom-e98f79ce2c5f#.5mlc5ju6h), который позволяет рендерит и обновлять DOM только в местах где изменились данные. А не перерендеривать шаблон заново. Что позволило увеличить быстродействие [на порядок](https://auth0.com/blog/2016/01/11/updated-and-improved-more-benchmarks-virtual-dom-vs-angular-12-vs-mithril-js-vs-the-rest/).   

Это значительно упрощает работу с View. Достаточно описать как должен выглядит ваш шаблон в зависимости от в входных данных и дальше RAD.js позаботиться о том как нужно обновить DOM.  

Со стороны процесс обновления View становится похожим на обновления компонентов в React.js: меняются данные → вызывается рендер шаблона → обновляется DOM только в тех местах где данные изменились.   

Но в отличии от React.js или VirtualDOM в Rad.js нет промежуточного виртуального дерева и нет дополнительных затрат на процесс сравнения виртуального и реального DOM.  

При этом вы как и раньше можете использовать существующие инструменты Backbone.js: [Backbone.Model](http://backbonejs.org/#Model), [Backbone.Collection](http://backbonejs.org/#Collection), [Backbone.Router](http://backbonejs.org/#Router).

## Nested View

Говоря честно, нам очень нравиться когда с `view` можно работать как с как с компонентом, то есть инжектить его в templates, тем самым инкапсулировать функциональность. И именно этого функционала очень часто не хватает. Поэтому мы постарались реализовать дополнительные механизмы Dependency Injection в нашем фреймверке.

## Заключение
Как многие смогут заметив прочитав данную документацию: **RAD.js** очень похож на **Backbone.js** с функциональностью **React.js**. 

И хотя нам очень нравиться **React.js** своими идеями и мы используем его для написания некоторых из своих приложений.

Зачем же надобыло изобретать что то новое?

Существуют как минимум три причины:

* Очень много разработчиком знают **Backbone.js** и иногда именно на основе **Backbone.js** бывает проще реализовать необходимую функциональность приложения.
* **RAD.js** как надстройка над **Backbone.js** не вносит каких либо дополнительных ограничений на структуру и архитектуру вашего приложения. В отличии от того же **React.js**, который тянет за собой новую экоситему, которая совершенствееться каждый день, но которая не может быть идеальна для каждого случая, по простой причине - серебряных пуль просто не существует!
* Разработка любого приложения это использование стороннего кода и сторонних библотек. И именно по этой причине мы использовали **incremental DOM** как наиболее гибкий и производительный движок для Virtual DOM. Который не вносит колизий при использовании стороннего кода, модифицирующего структуру DOM.